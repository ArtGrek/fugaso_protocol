//! `SeaORM` Entity. Generated by sea-orm-codegen 0.11.2
use sea_orm::entity::prelude::*;
use sea_orm::Unchanged;
use serde::{Deserialize, Serialize};
use crate::model::ActiveClone;

#[derive(Debug, PartialEq, Eq, Hash, Clone,
EnumIter, DeriveActiveEnum, Deserialize, Serialize, Default)]
#[sea_orm(rs_type = "String", db_type = "String(Some(15))")]
#[allow(non_camel_case_types)]
pub enum ActionKind {
    #[sea_orm(string_value = "BET")]
    #[default]
    BET,
    #[sea_orm(string_value = "SPIN")]
    SPIN,
    #[sea_orm(string_value = "BET_LINE")]
    BET_LINE,
    #[sea_orm(string_value = "BET_LINE_DENOM")]
    BET_LINE_DENOM,
    #[sea_orm(string_value = "BET_LINE_REELS")]
    BET_LINE_REELS,
    #[sea_orm(string_value = "FREE_COLLECT")]
    FREE_COLLECT,
    #[sea_orm(string_value = "COLLECT")]
    COLLECT,
    #[sea_orm(string_value = "COLLECT_START")]
    COLLECT_START,
    #[sea_orm(string_value = "FREE_COLLECT_START")]
    FREE_COLLECT_START,
    #[sea_orm(string_value = "HALF_COLLECT")]
    HALF_COLLECT,
    #[sea_orm(string_value = "CLOSE")]
    CLOSE,
    #[sea_orm(string_value = "GAMBLE_PLAY")]
    GAMBLE_PLAY,
    #[sea_orm(string_value = "GAMBLE_END")]
    GAMBLE_END,
    #[sea_orm(string_value = "GAMBLE_FREE_END")]
    GAMBLE_FREE_END,
    #[sea_orm(string_value = "FREE_SPIN")]
    FREE_SPIN,
    #[sea_orm(string_value = "FREESPIN_START")]
    FREESPIN_START,
    #[sea_orm(string_value = "RESPIN")]
    RESPIN,
    #[sea_orm(string_value = "RESPIN_START")]
    RESPIN_START,
    #[sea_orm(string_value = "DROP")]
    DROP,
    #[sea_orm(string_value = "DROP_START")]
    DROP_START,
    #[sea_orm(string_value = "BONUS")]
    BONUS,
    #[sea_orm(string_value = "BONUS_START")]
    BONUS_START,
}

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Default)]
#[sea_orm(table_name = "game_scale_action")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: i64,
    #[sea_orm(column_name = "actdescr")]
    pub act_descr: Option<ActionKind>,
    pub amount: i64,
    #[sea_orm(column_name = "freegames")]
    pub free_games: Option<String>,
    pub holds: Option<String>,
    pub lines: Option<String>,
    #[sea_orm(column_name = "nextact")]
    pub next_act: Option<ActionKind>,
    #[sea_orm(column_name = "nextcombo")]
    pub next_combo: i32,
    #[sea_orm(column_name = "reelcombo")]
    pub reel_combo: i32,
    #[sea_orm(column_name = "reelstops")]
    pub reel_stops: Option<String>,
    #[sea_orm(column_name = "timedone")]
    pub time_done: Option<DateTime>,
    pub round_id: Option<i64>,
    pub cards: Option<String>,
    pub choice: Option<String>,
    #[sea_orm(column_type = "Text", nullable)]
    pub special: Option<String>,
    #[sea_orm(unique, column_name = "externalid")]
    pub external_id: Option<String>,
    #[sea_orm(column_type = "Text", nullable)]
    pub custom: Option<String>,
    pub grid: Option<String>,
    pub remote_code: Option<i32>,
    #[sea_orm(column_type = "Text", nullable)]
    pub error_info: Option<String>,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
    belongs_to = "super::fugaso_round::Entity",
    from = "Column::RoundId",
    to = "super::fugaso_round::Column::Id",
    on_update = "NoAction",
    on_delete = "NoAction"
    )]
    Round,
}

impl Related<super::fugaso_round::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Round.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}


impl ActiveClone<ActiveModel> for Model {
    fn clone_active_model(&self) -> ActiveModel {
        ActiveModel {
            id: Unchanged(self.id),
            act_descr: Unchanged(self.act_descr.clone()),
            amount: Unchanged(self.amount),
            free_games: Unchanged(self.free_games.clone()),
            holds: Unchanged(self.holds.clone()),
            lines: Unchanged(self.lines.clone()),
            next_act: Unchanged(self.next_act.clone()),
            next_combo: Unchanged(self.next_combo),
            reel_combo: Unchanged(self.reel_combo),
            reel_stops: Unchanged(self.reel_stops.clone()),
            time_done: Unchanged(self.time_done),
            round_id: Unchanged(self.round_id),
            cards: Unchanged(self.cards.clone()),
            choice: Unchanged(self.choice.clone()),
            special: Unchanged(self.special.clone()),
            external_id: Unchanged(self.external_id.clone()),
            custom: Unchanged(self.custom.clone()),
            grid: Unchanged(self.grid.clone()),
            remote_code: Unchanged(self.remote_code),
            error_info: Unchanged(self.error_info.clone()),
        }
    }

    fn unchanged_active_model() -> ActiveModel {
        ActiveModel {
            id: Unchanged(0),
            act_descr: Unchanged(Some(ActionKind::CLOSE)),
            amount: Unchanged(0),
            free_games: Unchanged(None),
            holds: Unchanged(None),
            lines: Unchanged(None),
            next_act: Unchanged(None),
            next_combo: Unchanged(0),
            reel_combo: Unchanged(0),
            reel_stops: Unchanged(None),
            time_done: Unchanged(None),
            round_id: Unchanged(None),
            cards: Unchanged(None),
            choice: Unchanged(None),
            special: Unchanged(None),
            external_id: Unchanged(None),
            custom: Unchanged(None),
            grid: Unchanged(None),
            remote_code: Unchanged(None),
            error_info: Unchanged(None),
        }
    }
}